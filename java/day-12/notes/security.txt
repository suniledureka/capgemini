Securing Spring Boot Application with Spring Security
=====================================================
What is Security?
----------------
Security is for protecting your data and business logic inside our application
Our company data - employee details, projects details

ECommerce Site - Product Details, Reseller Details, Customer Details, Order Details etc

Security is a Non Functional Requirement - No client will specifically asks that he need security

Security From Development Phase - Security should be considered from development phase itself along with business logic (not at the last)

Different Types of Security - Security for an application will be implemented in different ways like using firewalls, HTTPS, SSL, Authentication, Authorization etc

Authentication Vs Authorization
-------------------------------
Basic thing of Security is Authentication & Authorization

Authentication -> Verifies who you are: college student, company employee
Authorization -> decides whether you have permission to access a resource:
User XYZ can only read data	 User ABC can read and update data

#1 in authentication - the identity of users are checked for providing the access to the system (implementing login functionality).  in authorization - user's authorities are checked for accessing the resources

#2 authentication done before authorization           		
   authorization always happens after authentication

#3 authentication usually needs user's login details     	
   authorization needs user's privileges or roles

#4 if authentication fails usually we will get 401 error response
   if authorization fails usually we will get 403 error response


How does Spring MVC Work?
DispatcherServlet acts as the front controller
  -> Intercepts all requests
  -> Routes to the Right Controller
   Request ---> DispatcherServlet ----> Controller(s)


How does Spring Security Work?

Spring security intercepts all requests
Spring security executes a series of filters - also called Spring Security Filter Chain
   Request ---> Spring Security ---> DispatcherServlet ----> Controller(s)
  

Filters provide these features:
    - Authentication: Is it a valid user? (Ex: BasicAuthenticationFilter)
    - Authorization: Does the user have right access?(Ex: AuthorizationFilter)

   Other Features:
    - Cross-Origin Resource Sharing (CORS) - CorsFilter
        Should you allow AJAX calls from other domains?
        Ex: if you are building a fullstack application, you have the frontend deployed to one domain like React and the backend rest api deployed to another domain. the backend REST API should allow calls from the frontend  application which is running in the browser - this can be configured usingCORS

    - Cross Site Request Forgery (CSRF) - CsrfFilter
       - typically a user session is created for you once you login to a site/web application, and a user session is typically identified by using a cookie in the browser, if you don't logout from that site and you go to a malicious web site - this site can make use of the previous authentication that you have - the cookie which is present in the browser. this vulnerability is known as CSRF. when we add spring security - CSRF is automatically enabled for any update/ delete requests

	A malicious website making use of previous authentication on your website
	Default: CSRF protection enabled for update requests - POST, PUT etc..

Spring security provides a default Login Page, Logout Page
	LogoutFilter, DefaultLoginPageGeneratingFilter, DefaultLogoutPageGeneratingFilter
     Translating exceptions into proper Http Responses (ExceptionTranslationFilter)

Order of filters is important (typical order is)
  1: Basic Check Filters - CORS, CSRF, ..
  2: Authentication Filters - do they have the correct credentials
  3: Authorization Filters - do they have the right access to perform the right action on the right resource


------- Practicals -----

CSRF - Cross Site Request Forgery

-> you are logged-in to your bank's online platform; which creates a cookie and will be saved in your browser
-> you open a malicious website without logging out from the bank's application
-> other website may execute a bank transfer on your bank account without your knowledge using the cookie of bank in your system's browser
-- this is called as CSRF


How can you protect from CSRF?
1) Synchronizer Token Pattern
   - create a new token for each & every request
   - spring security enables this by default
   - to make any updates (POST, PUT, DELETE...), you need a CSRF token from the previous request


02.sb-security-csrf-app

record Product(Integer productId, String productName) {}


###---- Creating Spring Security Configuration to disable CSRF ----####

package com.wipro.boot.security.configs;
@Configuration
public class BasicSecurityConfiguration {
@Bean
 public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
   //--- default configuration ----
   http.authorizeHttpRequests(request -> request.anyRequest().authenticated());
   http.csrf(csrf ->csrf.disable());
   http.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
   http.httpBasic(Customizer.withDefaults());
   return http.build();   
 }
}  
run the application - search for csrf in logs       **run post request without csrf header - and it works


2) Same-Site Cookie (SameSite-Strict=Strict)
in application.properties
 server.servlet.session.cookie.same-site=strict


default web security configuration details are available with 
 - SpringBootWebSecurityConfiguration / WebSecurityConfigurerAdapter (SB 2.x)
 - WebSecurityConfiguration (SB 3.2)


Working with CORS
-----------------
- Cross Origin Resource Sharing
- browsers do not allow AJAX calls to resources outside current origin
- let us imagine, that we have a full-stack application, and your frontend is making a REST API call to a different domain (a different URL), typically our browser will not allow that kind of calls

- Cross-Origin Resource Sharing (CORS) is a specification that allows you to configure which cross-domain requests are allowed

- there are 2 approaches that we can follow
 (1) Global Configuration  - applicable to all rest controllers/resources 
   Configure addCorsMappings callback method in WebMvcConfigurer      (BasicSecurityConfiguration.java)
/*--- global configuration for CORS ----*/
@Bean
public WebMvcConfigurer corsConfigurer() {
  return new WebMvcConfigurer() {
    public void addCorsMappings(CorsRegistry registry) {
      registry.addMapping("/**")
              .allowedMethods("*")
              .allowedOrigins("http://localhost:3000");
  } };
}


(2) Local Configuration
  @CrossOrigin - Allow from all origins
  @CrossOrigin(origins = "https://lcalhost:3000") - Allow from specific origin



Storing User Credentials

1) Default Credentials - which are generated by Spring Security 

2) We can configure credentials in application.properties file
   spring.security.user.name = sunil
   spring.security.user.password = sunil@123

3) We can configure user credentials with In-Memory of our application (In-Memory Credentials)

4) We can configure user credentials in Database (JDBC Authentication)

5) We can configure user credentials in LDAP Server (LDAP Authentication) - Lightweight Directory Access Protocol    Open protocol for directory services and authentication



05.sb-security-auth
======================================================================================
JWT  jwt.io

-> JWT stands for JSON Web Token.

-> It is a token implementation which will be in the JSON format and designed to use for the web requests

-> JWT is most common and favorite token type that many systems use these days due to its features and advantages
Eg: while doing an online transfer of amount - OTP is required. We can consider OTP as a token

-> JWT Token can be used in both Authentication & Authorization scenario


JSON Web Tokens are an open, industry standard method for representing claims security between two parties. 
jwt.io allows you to decode, verify and generate JWT

JWT is the best secured way to communicate between the client and server and the advantages of using JWT is that it completely follows stateless authentication mechanism - it means all the user inputs or state is never saved in server memory or cookies.    
Why JWT? Traditional Approach

 

JWT contains username and  password in an encrypted manner with some other details

 
Sample JWT

A JWS - JSON Web Signature (the most common type of JWT) contains three parts separated by a dot ( . ). The first two parts (the "header" and "payload") are Base64-URL encoded JSON, and the third is a cryptographic signature

-> A JWT token has 3 parts which are separated by dot (.)
Sample JWT token

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

1) Header - represents header information which contains name of algorithm & type of token
2) Payload- claims information will be available here details)
   (registered claims / public claims / private claims)
3) Signature - encoded header + encoded payload + secret key

Decoded JWT
Header 
{
  "alg": "HS256",
  "typ": "JWT"
}
Refer: https://jwt.io/       https://jwt.io/introduction 
We can decode JWT Token using https://jwt.io/#debugger-io

alg – algorithm    typ – type of token    sub – subject    iat – Issued at

JWT Work Flow

Practicals -> Spring Boot Application with JWT Token

-> In our spring boot application we have 2 endpoints 
    1) /hello	    2) /token

---> /hello endpoint is token based secured endpoint; if token is valid then only /hello endpoint will be executed

---> /token endpoint is used for getting JWT token based on user credentials.  If credentials are valid then only token will be generated 

Note : 
username: admin
password: admin@123




New Project -> sb-security-jwt-app






logging.pattern.console= %green(%d{dd-MMM-yyyy HH:mm:ss.SSS}) %blue(%-5level) %red([%thread]) %yellow(%logger) %msg %n











https://www.bezkoder.com/websecurityconfigureradapter-deprecated-spring-boot/
https://www.codejava.net/frameworks/spring-boot/fix-websecurityconfigureradapter-deprecated
from boot 2.7.x

Reference: 
1) https://reflectoring.io/spring-security/
2) https://www.bezkoder.com/spring-boot-security-jwt/


@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http.authorizeRequests()
			.antMatchers("/home","/care")
			.permitAll()
			.antMatchers("/balance","/loan","/statement")
			.authenticated()
			.and().formLogin()
			.and().httpBasic();
		
		return http.build();
	}	
}



@Configuration
public class BasicSecurityConfiguration {
 @Bean
 public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {	
   http.authorizeHttpRequests(request -> request.requestMatchers("/home","/care").permitAll()
	.anyRequest().authenticated());
   http.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
   http.csrf().disable();
   http.headers().frameOptions().sameOrigin();
   http.httpBasic();
   return http.build();
}


