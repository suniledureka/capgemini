-------------------- PRACTICALS ---> One-To-One Mapping ------------

Usecase : relationship between Employee and Address
Any Employee should have an Address
Two Employees should not have the same Address

In a one to one mapping, both entities are tightly coupled. 
After the Employee is removed, we cannot use his/her Address. So we should define CascadeType as ALL(If you want to keep the Address, change it to PERSIST). Then address won't be deleted even we delete the Employee. 
Since Hibernate decides FetchType for one to one mapping is EAGER by default

Normally we record child entity primary key as the foreign key of the owner entity. So Employee should have a column in the table to record the address ID. We will give its name as "ADDRESS_ID" and its referenced by "ID" column in Address entity.

------ application.properties --------
# Datasource properties
spring.datasource.url=jdbc:mysql://localhost:3306/db_modeln
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# ORM Properties
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.hibernate.ddl-auto=update

------ Employee.java ------
package com.modeln.mappings.oto.entity;
@Entity
@Data
public class Employee {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;
	private String employeeName;
	@OneToOne(cascade = CascadeType.ALL)
	@JoinColumn(name = "address_id", referencedColumnName = "id")
	private Address employeeAddress;
}

------ Address.java --------
package com.modeln.mappings.oto.entity;
@Entity
@Data
public class Address {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;
	private String street;
	private String city;
	private String state;
}

------- EmployeeRepository.java -----------
package com.modeln.mappings.oto.repositories;
public interface EmployeeRepository extends JpaRepository<Employee, Long> {}

------- AddressRepository.java ------------
package com.modeln.mappings.oto.repositories;
public interface AddressRepository extends JpaRepository<Address, Long> {}

------- EmployeeAddressService ------------
package com.modeln.mappings.oto.services;
@Service
public class EmployeeAddressServices {
	@Autowired
	private EmployeeRepository employeeRepo;
	
	public void saveEmployeeAddress(Employee emp) {
		employeeRepo.save(emp);
	}

}

------- Application.java -------------
@SpringBootApplication
public class Application {	
		
	public static void main(String[] args) {
		ApplicationContext context = SpringApplication.run(Application.class, args);
		  Employee emp = new Employee(); 
		  emp.setEmloyeeName("Sanjay Patil");
		  
		  Address addr = new Address(); 
		  addr.setStreet("Mothinagar");
		  addr.setCity("Hyderabad"); 
		  addr.setState("Telangana");		  
		  
		  emp.setEmployeeAddress(addr);
		  
		  EmployeeAddressServices service = context.getBean(EmployeeAddressServices.class);
		  service.saveEmployeeAddress(emp);
	}
}

alter table employee auto_increment 100;


------- lazy loading --------------------
spring.jpa.properties.hibernate.enable_lazy_load_no_trans=true

@OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY)   [Employee entity class]


----------- to have a Bi directional one-to-one mapping  ----------
@Entity
@Data
public class Address {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;
	private String street;
	private String city;
	private String state;
	
	@OneToOne(mappedBy = "employeeAddress")	
	//@JsonIgnore
	private Employee employee;
}

In the child entity(Address), we just need to link the name of the property mapped in Employee entity.

"@JsonIgnore" annotation was placed there for user property since I do not need to have the user object to be seen in Address data. Just to ignore that field from JSON object.


----------- PRACTICALS # 2 -----------------------------
Person & Passport

package com.modeln.mappings.oto.entity;
@Entity
@Data
public class Person {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Integer personId;

	private String personName;

	private String personGender;

	@OneToOne(mappedBy = "person", cascade = CascadeType.ALL)
	private Passport passport;
}


package com.modeln.mappings.oto.entity;
@Entity
@Data
public class Passport {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Integer passportId;

	private String passPortNum;

	private LocalDate issuedDate;

	private LocalDate expDate;
	
	@OneToOne
	@JoinColumn(name = "person_id")
	private Person person;
}


PassportRepository & PersonRepository

package com.modeln.mappings.oto.services;
@Service
public class PersonServices {
	@Autowired
	private PersonRepository personRepo;
	@Autowired
	private PassportRepository passportRepo;
	
	public void saveData() {

		Person person = new Person();
		person.setPersonName("Praveen Kumar");
		person.setPersonGender("Male");

		Passport passport = new Passport();
		passport.setPassPortNum("RS12387");
		passport.setIssuedDate(LocalDate.now());
		passport.setExpDate(LocalDate.now().plusYears(10));

		person.setPassport(passport);
		passport.setPerson(person);

		personRepo.save(person);

	}
	
	public void deleteById(int id) {
		personRepo.deleteById(id);
	}
	
	public void searchByPassPortId(int id) {
		Passport pass = passportRepo.findById(id).get();
		System.out.println(pass.getPassPortNum());
	}
}

@SpringBootApplication
public class Application {	
		
	public static void main(String[] args) {
		ConfigurableApplicationContext context = SpringApplication.run(Application.class, args);
		
		PersonServices personService = context.getBean(PersonServices.class);
		
		//personService.saveData();
		//personService.deleteById(1);
		personService.searchByPassPortId(4);
	}
}



@JsonManagedReference annotation for the first objects instantiated

@JsonBackReference annotation for the second objects instantiated
